<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DC-IS3C Internet Standards Measurement Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            scroll-behavior: smooth;
            background: radial-gradient(circle at 20% 20%, rgba(56, 189, 248, 0.15), transparent 60%),
                        radial-gradient(circle at 80% 0%, rgba(56, 189, 248, 0.2), transparent 55%),
                        radial-gradient(circle at 10% 80%, rgba(14, 165, 233, 0.15), transparent 65%),
                        #020617;
            color: #0f172a;
        }
        .loader {
            border: 4px solid #f3f3f3; border-top: 4px solid #3b82f6;
            border-radius: 50%; width: 24px; height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .check-label { transition: all 0.2s ease-in-out; }
        .check-label:hover { background-color: rgba(148, 163, 184, 0.15); }
        .result-item .label { min-width: 140px; }
        .background-shape {
            position: absolute;
            border-radius: 9999px;
            filter: blur(40px);
            opacity: 0.65;
            mix-blend-mode: screen;
        }
        .shape-one {
            width: 420px;
            height: 420px;
            top: -160px;
            left: -120px;
            background: radial-gradient(circle, rgba(56, 189, 248, 0.35), transparent 60%);
        }
        .shape-two {
            width: 520px;
            height: 520px;
            bottom: -220px;
            right: -120px;
            background: radial-gradient(circle, rgba(59, 130, 246, 0.3), transparent 70%);
        }
    </style>
</head>
<body class="text-slate-100">
    <div class="relative min-h-screen overflow-hidden">
        <div class="background-shape shape-one"></div>
        <div class="background-shape shape-two"></div>
        <div class="relative z-10">
            <header class="max-w-6xl mx-auto px-6 pt-8 flex flex-col md:flex-row md:items-center md:justify-between gap-6">
                <div>
                    <p class="inline-flex items-center space-x-2 rounded-full bg-sky-500/10 px-4 py-1 text-sm font-medium text-sky-200">
                        <span data-i18n="navBadge">Dynamic Coalition on Internet Standards, Security &amp; Safety</span>
                    </p>
                    <h1 class="mt-4 text-2xl font-semibold text-white md:text-3xl" data-i18n="navTitle">Internet Standards Measurement Project</h1>
                    <p class="mt-1 text-sm text-slate-300 md:text-base" data-i18n="navSubtitle">An open intelligence workspace built with and for the global DC-IS3C community.</p>
                </div>
                <div class="flex items-center space-x-2 self-start md:self-auto">
                    <span class="text-xs uppercase tracking-wide text-slate-300" data-i18n="languageLabel">Interface language</span>
                    <div class="flex items-center rounded-full bg-white/10 p-1">
                        <button type="button" data-lang="en" class="language-toggle rounded-full px-3 py-1 text-sm font-medium text-white bg-sky-500 shadow" aria-label="Switch to English">ðŸ‡¬ðŸ‡§ EN</button>
                        <button type="button" data-lang="es" class="language-toggle rounded-full px-3 py-1 text-sm font-medium text-slate-200 hover:bg-white/10 transition" aria-label="Cambiar a espaÃ±ol">ðŸ‡ªðŸ‡¸ ES</button>
                        <button type="button" data-lang="pt" class="language-toggle rounded-full px-3 py-1 text-sm font-medium text-slate-200 hover:bg-white/10 transition" aria-label="Mudar para portuguÃªs">ðŸ‡§ðŸ‡· PT</button>
                    </div>
                </div>
            </header>

            <main class="max-w-6xl mx-auto px-6 pb-24">
                <section class="mt-12 grid gap-10 md:grid-cols-[1.1fr_0.9fr] md:items-center">
                    <div>
                        <p class="text-sm font-semibold uppercase tracking-wider text-sky-300" data-i18n="heroBadge">Global measurement intelligence</p>
                        <h2 class="mt-4 text-4xl font-bold leading-tight text-white md:text-5xl" data-i18n="heroTitle">Measure trust and security adoption across the open internet</h2>
                        <p class="mt-6 text-lg text-slate-200 md:text-xl" data-i18n="heroSubtitle">Run comprehensive diagnostics on domains, discover adoption gaps, and power evidence-based actions for the Dynamic Coalition on Internet Standards, Security and Safety (DC-IS3C).</p>
                        <div class="mt-8 flex flex-col gap-4 sm:flex-row sm:items-center">
                            <a href="#measurement" class="inline-flex items-center justify-center rounded-full bg-sky-500 px-6 py-3 text-base font-semibold text-white shadow-lg shadow-sky-500/30 transition hover:translate-y-[-1px] hover:bg-sky-400" data-i18n="heroCta">Launch the measurement console</a>
                            <button id="aboutBtn" type="button" class="inline-flex items-center justify-center rounded-full border border-white/30 px-6 py-3 text-base font-semibold text-white transition hover:border-white/60 hover:text-white/90" data-i18n="aboutButton">Why DC-IS3C built this</button>
                        </div>
                    </div>
                    <div class="grid gap-4">
                        <div class="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
                            <h3 class="text-lg font-semibold text-white" data-i18n="highlightOneTitle">Policy-grade observability</h3>
                            <p class="mt-2 text-sm text-slate-200" data-i18n="highlightOneText">Combine infrastructure, DNS, TLS, and application checks to understand readiness for critical internet standards.</p>
                        </div>
                        <div class="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
                            <h3 class="text-lg font-semibold text-white" data-i18n="highlightTwoTitle">Open collaboration</h3>
                            <p class="mt-2 text-sm text-slate-200" data-i18n="highlightTwoText">Share reproducible diagnostics across chapters, regulators, and research partners in the LAC region and beyond.</p>
                        </div>
                        <div class="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
                            <h3 class="text-lg font-semibold text-white" data-i18n="highlightThreeTitle">Future-ready insights</h3>
                            <p class="mt-2 text-sm text-slate-200" data-i18n="highlightThreeText">Feed actionable insights into the DC-IS3C roadmap, IS3C observatory, and regional capability-building initiatives.</p>
                        </div>
                    </div>
                </section>

                <section class="mt-16 rounded-3xl border border-white/10 bg-white/5 p-8 backdrop-blur-lg" id="aboutSection">
                    <div class="max-w-3xl">
                        <h2 class="text-2xl font-semibold text-white" data-i18n="aboutHeading">About the Dynamic Coalition on Internet Standards, Security and Safety</h2>
                        <p class="mt-4 text-base text-slate-200" data-i18n="aboutLead">DC-IS3C operates within the Internet Governance Forum (IGF) to advance the adoption of open, secure, and trustworthy standards for the global internet.</p>
                        <div id="aboutText" class="mt-4 hidden space-y-4 text-sm text-slate-200">
                            <p data-i18n="aboutParagraphOne">This measurement initiative equips policymakers, civil society, the private sector, and technical communities with verifiable data on how critical standards such as DNSSEC, RPKI, TLS, SMTPUTF8, SPF, DMARC, and emerging trust frameworks are deployed.</p>
                            <p data-i18n="aboutParagraphTwo">Through the DC-IS3C Dynamic Coalition, we connect regional effortsâ€”including Latin America and the Caribbean chapters of the Internet Societyâ€”with global observatories, capacity-building programs, and collaborative research teams.</p>
                            <p data-i18n="aboutParagraphThree">Every check in this suite is transparent, reproducible, and ready to be integrated into dashboards, policy briefs, and shared learning experiences across the coalition.</p>
                        </div>
                    </div>
                </section>

                <section class="mt-20" id="measurement">
                    <div class="w-full max-w-5xl mx-auto bg-white text-slate-900 rounded-3xl shadow-2xl shadow-sky-900/20 border border-slate-200/70 p-6 md:p-10">
                        <div class="text-center mb-6">
                            <p class="text-sm font-semibold uppercase tracking-wider text-sky-600" data-i18n="measurementBadge">Measurement Console</p>
                            <h2 class="mt-2 text-3xl font-bold text-slate-900" data-i18n="measurementHeading">Run cross-standard diagnostics in minutes</h2>
                            <p class="mt-3 text-base text-slate-600" data-i18n="measurementSubtitle">Select a focus country or paste domains, choose the verifications you need, and generate auditable reports for stakeholders.</p>
                        </div>

                        <div class="mb-6">
                            <label for="countrySelect" class="block text-sm font-medium text-slate-700 mb-2" data-i18n="countryLabel">Choose a focus country</label>
                            <select id="countrySelect" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition">
                                <option value="" selected disabled data-i18n="countryPlaceholder">-- Country --</option>
                            </select>
                        </div>

                        <div class="mb-6">
                            <label for="domains" class="block text-sm font-medium text-slate-700 mb-2" data-i18n="domainLabel">Domains (comma separated)</label>
                            <textarea id="domains" rows="3" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition" data-i18n-placeholder="domainPlaceholderText" placeholder="google.com, nic.uy, lacnic.net"></textarea>
                        </div>

                        <div class="mb-6">
                            <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                                <label class="block text-sm font-medium text-slate-700" data-i18n="checksLabel">Checks to run</label>
                                <button id="selectAll" type="button" class="text-sky-600 text-sm font-semibold" data-i18n="selectAll">Select all</button>
                            </div>
                            <div id="checksContainer" class="space-y-3 mt-3"></div>
                        </div>

                        <div class="flex flex-col items-center justify-center">
                            <button id="checkButton" class="bg-sky-600 text-white font-bold py-3 px-6 rounded-full hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 focus:ring-offset-white transition-transform transform hover:scale-105 flex items-center justify-center space-x-2">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M9 9a2 2 0 114 0 2 2 0 01-4 0z" /><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-13a4 4 0 00-3.446 6.032l-2.261 2.26a1 1 0 101.414 1.414l2.26-2.26a4 4 0 10-1.15-7.446z" clip-rule="evenodd" /></svg>
                                <span data-i18n="runButton">Run analysis</span>
                            </button>
                            <div class="flex flex-col gap-2 mt-4 sm:flex-row sm:gap-4">
                                <button id="historyButton" class="bg-slate-800 text-white font-semibold py-2 px-5 rounded-full hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-slate-500 focus:ring-offset-white" data-i18n="historyButton">View history</button>
                                <button id="clearHistoryButton" class="bg-slate-400 text-white font-semibold py-2 px-5 rounded-full hover:bg-slate-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-slate-400 focus:ring-offset-white" data-i18n="clearHistoryButton">Clear history</button>
                            </div>
                        </div>

                        <div id="history" class="mt-6 hidden"></div>
                        <div id="map" class="w-full h-64 mb-8 hidden rounded-2xl overflow-hidden border border-slate-200"></div>
                        <div id="results-container" class="mt-8 space-y-6">
                            <div id="summary" class="hidden bg-white border border-slate-200 rounded-2xl shadow-sm">
                                <div class="px-4 py-3 border-b border-slate-200">
                                    <h3 class="text-lg font-semibold text-slate-900" data-i18n="summaryTitle">Aggregate summary</h3>
                                    <p class="text-sm text-slate-500" data-i18n="summarySubtitle">Live totals by verification</p>
                                </div>
                                <div class="overflow-x-auto">
                                    <table class="min-w-full text-sm text-left">
                                        <thead class="bg-slate-50 text-slate-600 uppercase text-xs tracking-wide">
                                            <tr>
                                                <th class="px-4 py-3" data-i18n="summaryVerification">Verification</th>
                                                <th class="px-4 py-3" data-i18n="summaryYes">Yes</th>
                                                <th class="px-4 py-3" data-i18n="summaryNo">No</th>
                                            </tr>
                                        </thead>
                                        <tbody id="summaryBody" class="divide-y divide-slate-200 bg-white"></tbody>
                                    </table>
                                </div>
                            </div>
                            <div id="loader" class="hidden items-center justify-center py-4 text-slate-600">
                                <div class="loader"></div><p class="ml-3" data-i18n="loaderText">Running diagnosticsâ€¦</p>
                            </div>
                            <div id="results" class="space-y-6"></div>
                        </div>
                    </div>
                </section>
            </main>
        </div>
    </div>

<script>
    const checkButton = document.getElementById('checkButton');
    const domainsInput = document.getElementById('domains');
    const countrySelect = document.getElementById('countrySelect');
    const resultsContainer = document.getElementById('results');
    const loader = document.getElementById('loader');
    const summarySection = document.getElementById('summary');
    const summaryBody = document.getElementById('summaryBody');
    let checkboxes = [];
    const selectAllBtn = document.getElementById('selectAll');
    const historyButton = document.getElementById('historyButton');
    const clearHistoryButton = document.getElementById('clearHistoryButton');
    const historyDiv = document.getElementById('history');
    const aboutBtn = document.getElementById('aboutBtn');
    const aboutText = document.getElementById('aboutText');
    const mapDiv = document.getElementById('map');
    let map; let mapMarkers = [];
    let lastMapDomains = [];
    let summaryData = {};
    let summaryElements = {};
        const API_BASE = 'http://localhost:4000';
    const headerCache = {};
    const tlsCache = {};

    const localeMap = { en: 'en-US', es: 'es-ES', pt: 'pt-BR' };
    let currentLang = 'en';

    const translations = {
        en: {
            pageTitle: 'DC-IS3C Internet Standards Measurement Suite',
            navBadge: 'Dynamic Coalition on Internet Standards, Security & Safety',
            navTitle: 'Internet Standards Measurement Project',
            navSubtitle: 'An open intelligence workspace built with and for the global DC-IS3C community.',
            languageLabel: 'Interface language',
            heroBadge: 'Global measurement intelligence',
            heroTitle: 'Measure trust and security adoption across the open internet',
            heroSubtitle: 'Run comprehensive diagnostics on domains, discover adoption gaps, and power evidence-based actions for the Dynamic Coalition on Internet Standards, Security and Safety (DC-IS3C).',
            heroCta: 'Launch the measurement console',
            aboutButton: 'Why DC-IS3C built this',
            highlightOneTitle: 'Policy-grade observability',
            highlightOneText: 'Combine infrastructure, DNS, TLS, and application checks to understand readiness for critical internet standards.',
            highlightTwoTitle: 'Open collaboration',
            highlightTwoText: 'Share reproducible diagnostics across chapters, regulators, and research partners in the LAC region and beyond.',
            highlightThreeTitle: 'Future-ready insights',
            highlightThreeText: 'Feed actionable insights into the DC-IS3C roadmap, IS3C observatory, and regional capability-building initiatives.',
            aboutHeading: 'About the Dynamic Coalition on Internet Standards, Security and Safety',
            aboutLead: 'DC-IS3C operates within the Internet Governance Forum (IGF) to advance the adoption of open, secure, and trustworthy standards for the global internet.',
            aboutParagraphOne: 'This measurement initiative equips policymakers, civil society, the private sector, and technical communities with verifiable data on how critical standards such as DNSSEC, RPKI, TLS, SMTPUTF8, SPF, DMARC, and emerging trust frameworks are deployed.',
            aboutParagraphTwo: 'Through the DC-IS3C Dynamic Coalition, we connect regional effortsâ€”including Latin America and the Caribbean chapters of the Internet Societyâ€”with global observatories, capacity-building programs, and collaborative research teams.',
            aboutParagraphThree: 'Every check in this suite is transparent, reproducible, and ready to be integrated into dashboards, policy briefs, and shared learning experiences across the coalition.',
            measurementBadge: 'Measurement Console',
            measurementHeading: 'Run cross-standard diagnostics in minutes',
            measurementSubtitle: 'Select a focus country or paste domains, choose the verifications you need, and generate auditable reports for stakeholders.',
            countryLabel: 'Choose a focus country',
            countryPlaceholder: '-- Country --',
            domainLabel: 'Domains (comma separated)',
            domainPlaceholderText: 'google.com, nic.uy, lacnic.net',
            checksLabel: 'Checks to run',
            selectAll: 'Select all',
            runButton: 'Run analysis',
            historyButton: 'View history',
            clearHistoryButton: 'Clear history',
            summaryTitle: 'Aggregate summary',
            summarySubtitle: 'Live totals by verification',
            summaryVerification: 'Verification',
            summaryYes: 'Yes',
            summaryNo: 'No',
            loaderText: 'Running diagnosticsâ€¦',
            loadingIndicator: 'Loadingâ€¦',
            historyEmpty: 'No history yet',
            historyDomain: 'Domain',
            noPositiveResults: 'No positive results yet',
            noNegativeResults: 'No negative results yet',
            statusFailed: 'failed',
            statusError: 'error',
            mapGenerics: 'Generic TLDs',
            serviceUnavailable: 'Service unavailable',
            requestTimeout: 'Request timed out',
            summaryChecksSuffix: 'checks',
            groupNetwork: 'Network & IP intelligence',
            groupDns: 'DNS & infrastructure security',
            groupMail: 'Email & messaging',
            groupIdentity: 'Identity & accountability',
            groupExperience: 'Content & experience',
            groupSecurity: 'Web & TLS security'
        },
        es: {
            pageTitle: 'Suite de MediciÃ³n de EstÃ¡ndares de Internet DC-IS3C',
            navBadge: 'CoaliciÃ³n DinÃ¡mica sobre EstÃ¡ndares, Seguridad y Confianza en Internet',
            navTitle: 'Proyecto de MediciÃ³n de EstÃ¡ndares de Internet',
            navSubtitle: 'Un espacio abierto de inteligencia creado con y para la comunidad global de DC-IS3C.',
            languageLabel: 'Idioma de la interfaz',
            heroBadge: 'Inteligencia de mediciÃ³n global',
            heroTitle: 'Mide la adopciÃ³n de confianza y seguridad en el internet abierto',
            heroSubtitle: 'Ejecuta diagnÃ³sticos integrales sobre dominios, identifica brechas de adopciÃ³n y habilita acciones basadas en evidencia para la CoaliciÃ³n DinÃ¡mica sobre EstÃ¡ndares, Seguridad y Confianza en Internet (DC-IS3C).',
            heroCta: 'Ir a la consola de mediciÃ³n',
            aboutButton: 'Â¿Por quÃ© DC-IS3C creÃ³ esto?',
            highlightOneTitle: 'Observabilidad a nivel de polÃ­ticas',
            highlightOneText: 'Combina verificaciones de infraestructura, DNS, TLS y aplicaciones para comprender la preparaciÃ³n frente a estÃ¡ndares crÃ­ticos de internet.',
            highlightTwoTitle: 'ColaboraciÃ³n abierta',
            highlightTwoText: 'Comparte diagnÃ³sticos reproducibles entre capÃ­tulos, reguladores y aliados de investigaciÃ³n en la regiÃ³n LAC y mÃ¡s allÃ¡.',
            highlightThreeTitle: 'InformaciÃ³n preparada para el futuro',
            highlightThreeText: 'Incorpora ideas accionables al plan de DC-IS3C, al observatorio de IS3C y a iniciativas regionales de fortalecimiento de capacidades.',
            aboutHeading: 'Acerca de la CoaliciÃ³n DinÃ¡mica sobre EstÃ¡ndares, Seguridad y Confianza en Internet',
            aboutLead: 'DC-IS3C actÃºa dentro del Foro de Gobernanza de Internet (IGF) para impulsar la adopciÃ³n de estÃ¡ndares abiertos, seguros y confiables para el internet global.',
            aboutParagraphOne: 'Esta iniciativa de mediciÃ³n entrega a responsables de polÃ­ticas, sociedad civil, sector privado y comunidades tÃ©cnicas datos verificables sobre cÃ³mo se implementan estÃ¡ndares crÃ­ticos como DNSSEC, RPKI, TLS, SMTPUTF8, SPF, DMARC y nuevos marcos de confianza.',
            aboutParagraphTwo: 'A travÃ©s de la CoaliciÃ³n DinÃ¡mica DC-IS3C conectamos los esfuerzos regionales â€”incluidos los capÃ­tulos de Internet Society en AmÃ©rica Latina y el Caribeâ€” con observatorios globales, programas de capacitaciÃ³n y equipos de investigaciÃ³n colaborativa.',
            aboutParagraphThree: 'Cada verificaciÃ³n de esta suite es transparente, reproducible y apta para integrarse en tableros, informes de polÃ­tica y experiencias de aprendizaje compartido en toda la coaliciÃ³n.',
            measurementBadge: 'Consola de mediciÃ³n',
            measurementHeading: 'Ejecuta diagnÃ³sticos multiestÃ¡ndar en minutos',
            measurementSubtitle: 'Selecciona un paÃ­s de referencia o pega dominios, elige las verificaciones necesarias y genera informes auditables para las partes interesadas.',
            countryLabel: 'Elige un paÃ­s de referencia',
            countryPlaceholder: '-- PaÃ­s --',
            domainLabel: 'Dominios (separados por coma)',
            domainPlaceholderText: 'google.com, nic.uy, lacnic.net',
            checksLabel: 'Verificaciones a ejecutar',
            selectAll: 'Seleccionar todo',
            runButton: 'Ejecutar anÃ¡lisis',
            historyButton: 'Ver historial',
            clearHistoryButton: 'Limpiar historial',
            summaryTitle: 'Resumen acumulado',
            summarySubtitle: 'Totales en vivo por verificaciÃ³n',
            summaryVerification: 'VerificaciÃ³n',
            summaryYes: 'SÃ­',
            summaryNo: 'No',
            loaderText: 'Ejecutando diagnÃ³sticosâ€¦',
            loadingIndicator: 'Cargandoâ€¦',
            historyEmpty: 'Sin historial aÃºn',
            historyDomain: 'Dominio',
            noPositiveResults: 'Sin resultados positivos',
            noNegativeResults: 'Sin resultados negativos',
            statusFailed: 'fallÃ³',
            statusError: 'error',
            mapGenerics: 'TLD genÃ©ricos',
            serviceUnavailable: 'Servicio no disponible',
            requestTimeout: 'Tiempo de espera agotado',
            summaryChecksSuffix: 'controles',
            groupNetwork: 'Inteligencia de red e IP',
            groupDns: 'DNS y seguridad de infraestructura',
            groupMail: 'Correo y mensajerÃ­a',
            groupIdentity: 'Identidad y responsabilidad',
            groupExperience: 'Contenido y experiencia',
            groupSecurity: 'Seguridad web y TLS'
        },
        pt: {
            pageTitle: 'Suite de MediÃ§Ã£o de PadrÃµes de Internet DC-IS3C',
            navBadge: 'CoalizÃ£o DinÃ¢mica sobre PadrÃµes, SeguranÃ§a e ConfianÃ§a na Internet',
            navTitle: 'Projeto de MediÃ§Ã£o de PadrÃµes de Internet',
            navSubtitle: 'Um espaÃ§o aberto de inteligÃªncia criado com e para a comunidade global da DC-IS3C.',
            languageLabel: 'Idioma da interface',
            heroBadge: 'InteligÃªncia de mediÃ§Ã£o global',
            heroTitle: 'MeÃ§a a adoÃ§Ã£o de confianÃ§a e seguranÃ§a na internet aberta',
            heroSubtitle: 'Execute diagnÃ³sticos abrangentes em domÃ­nios, descubra lacunas de adoÃ§Ã£o e apoie aÃ§Ãµes baseadas em evidÃªncias para a CoalizÃ£o DinÃ¢mica sobre PadrÃµes, SeguranÃ§a e ConfianÃ§a na Internet (DC-IS3C).',
            heroCta: 'Abrir a consola de mediÃ§Ã£o',
            aboutButton: 'Por que a DC-IS3C criou isto',
            highlightOneTitle: 'Observabilidade para polÃ­ticas pÃºblicas',
            highlightOneText: 'Combine verificaÃ§Ãµes de infraestrutura, DNS, TLS e aplicaÃ§Ãµes para entender a prontidÃ£o para padrÃµes crÃ­ticos da internet.',
            highlightTwoTitle: 'ColaboraÃ§Ã£o aberta',
            highlightTwoText: 'Compartilhe diagnÃ³sticos reproduzÃ­veis entre capÃ­tulos, reguladores e parceiros de pesquisa na regiÃ£o LAC e alÃ©m.',
            highlightThreeTitle: 'Insights preparados para o futuro',
            highlightThreeText: 'Leve insights acionÃ¡veis ao roteiro da DC-IS3C, ao observatÃ³rio da IS3C e a iniciativas regionais de capacitaÃ§Ã£o.',
            aboutHeading: 'Sobre a CoalizÃ£o DinÃ¢mica de PadrÃµes, SeguranÃ§a e ConfianÃ§a na Internet',
            aboutLead: 'A DC-IS3C atua dentro do FÃ³rum de GovernanÃ§a da Internet (IGF) para promover a adoÃ§Ã£o de padrÃµes abertos, seguros e confiÃ¡veis para a internet global.',
            aboutParagraphOne: 'Esta iniciativa de mediÃ§Ã£o oferece a formuladores de polÃ­ticas, sociedade civil, setor privado e comunidades tÃ©cnicas dados verificÃ¡veis sobre como padrÃµes crÃ­ticos como DNSSEC, RPKI, TLS, SMTPUTF8, SPF, DMARC e novos marcos de confianÃ§a sÃ£o implementados.',
            aboutParagraphTwo: 'Por meio da CoalizÃ£o DinÃ¢mica DC-IS3C conectamos esforÃ§os regionais â€” incluindo capÃ­tulos da Internet Society na AmÃ©rica Latina e Caribe â€” a observatÃ³rios globais, programas de capacitaÃ§Ã£o e equipes de pesquisa colaborativa.',
            aboutParagraphThree: 'Cada verificaÃ§Ã£o desta suÃ­te Ã© transparente, reproduzÃ­vel e pronta para integraÃ§Ã£o em painÃ©is, relatÃ³rios de polÃ­ticas e experiÃªncias de aprendizagem compartilhada em toda a coalizÃ£o.',
            measurementBadge: 'Consola de mediÃ§Ã£o',
            measurementHeading: 'Execute diagnÃ³sticos multivariados em minutos',
            measurementSubtitle: 'Selecione um paÃ­s de referÃªncia ou cole domÃ­nios, escolha as verificaÃ§Ãµes necessÃ¡rias e gere relatÃ³rios auditÃ¡veis para as partes interessadas.',
            countryLabel: 'Escolha um paÃ­s de referÃªncia',
            countryPlaceholder: '-- PaÃ­s --',
            domainLabel: 'DomÃ­nios (separados por vÃ­rgula)',
            domainPlaceholderText: 'google.com, nic.uy, lacnic.net',
            checksLabel: 'VerificaÃ§Ãµes a executar',
            selectAll: 'Selecionar tudo',
            runButton: 'Executar anÃ¡lise',
            historyButton: 'Ver histÃ³rico',
            clearHistoryButton: 'Limpar histÃ³rico',
            summaryTitle: 'Resumo agregado',
            summarySubtitle: 'Totais em tempo real por verificaÃ§Ã£o',
            summaryVerification: 'VerificaÃ§Ã£o',
            summaryYes: 'Sim',
            summaryNo: 'NÃ£o',
            loaderText: 'Executando diagnÃ³sticosâ€¦',
            loadingIndicator: 'Carregandoâ€¦',
            historyEmpty: 'Sem histÃ³rico ainda',
            historyDomain: 'DomÃ­nio',
            noPositiveResults: 'Sem resultados positivos',
            noNegativeResults: 'Sem resultados negativos',
            statusFailed: 'falhou',
            statusError: 'erro',
            mapGenerics: 'TLD genÃ©ricos',
            serviceUnavailable: 'ServiÃ§o indisponÃ­vel',
            requestTimeout: 'Tempo limite da solicitaÃ§Ã£o',
            summaryChecksSuffix: 'verificaÃ§Ãµes',
            groupNetwork: 'InteligÃªncia de rede e IP',
            groupDns: 'DNS e seguranÃ§a de infraestrutura',
            groupMail: 'Email e mensageria',
            groupIdentity: 'Identidade e responsabilidade',
            groupExperience: 'ConteÃºdo e experiÃªncia',
            groupSecurity: 'SeguranÃ§a web e TLS'
        }
    };

    function t(key) {
        const dict = translations[currentLang] || translations.en;
        return dict[key] ?? translations.en[key] ?? key;
    }

    function applyTranslations() {
        const dict = translations[currentLang] || translations.en;
        document.title = dict.pageTitle;
        document.documentElement.lang = currentLang;
        document.querySelectorAll('[data-i18n]').forEach(el => {
            const key = el.getAttribute('data-i18n');
            if (!key) return;
            const value = dict[key] ?? translations.en[key];
            if (value) {
                el.textContent = value;
            }
        });
        document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
            const key = el.getAttribute('data-i18n-placeholder');
            const value = dict[key] ?? translations.en[key];
            if (value) {
                el.setAttribute('placeholder', value);
            }
        });
        document.querySelectorAll('[data-group-title]').forEach(el => {
            const key = el.dataset.groupTitle;
            if (key) {
                el.textContent = t(key);
            }
        });
        document.querySelectorAll('[data-group-count]').forEach(el => {
            const count = el.dataset.groupCount;
            const suffix = t('summaryChecksSuffix');
            if (count) {
                el.textContent = `${count} ${suffix}`;
            }
        });
    }

    const languageButtons = document.querySelectorAll('.language-toggle');
    languageButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            currentLang = btn.dataset.lang || 'en';
            languageButtons.forEach(b => {
                b.classList.remove('bg-sky-500', 'text-white', 'shadow');
                b.classList.add('text-slate-200');
            });
            btn.classList.add('bg-sky-500', 'text-white', 'shadow');
            btn.classList.remove('text-slate-200');
            applyTranslations();
            if (!historyDiv.classList.contains('hidden')) {
                loadHistory();
            }
            Object.keys(summaryElements).forEach(key => {
                const elements = summaryElements[key];
                if (!elements) return;
                const data = summaryData[key] || { positives: [], negatives: [] };
                elements.positiveTooltip.innerHTML = renderTooltipList(data.positives || [], t('noPositiveResults'), true);
                elements.negativeTooltip.innerHTML = renderTooltipList(data.negatives || [], t('noNegativeResults'));
            });
            if (lastMapDomains.length) {
                updateMap(lastMapDomains);
            }
        });
    });

    applyTranslations();

    const countryTlds = {
        'Uruguay': ['uy','com.uy','edu.uy','gub.uy','org.uy','net.uy','mil.uy','destinosnaturales.gub.uy','agesic.gub.uy'],
        'Argentina': ['ar','com.ar','gob.ar','edu.ar','org.ar','net.ar'],
        'Brasil': ['br','com.br','gov.br','edu.br','org.br','net.br'],
        'Ecuador': ['ec','com.ec','gob.ec','edu.ec','org.ec','net.ec'],
        'Bolivia': ['bo','com.bo','gob.bo','edu.bo','org.bo','net.bo'],
        'Chile': ['cl','com.cl','gob.cl','edu.cl','org.cl','net.cl'],
        'Paraguay': ['py','com.py','gov.py','edu.py','org.py','net.py'],
        'PerÃº': ['pe','com.pe','gob.pe','edu.pe','org.pe','net.pe'],
        'Colombia': ['co','com.co','gov.co','edu.co','org.co','net.co'],
        'MÃ©xico': ['mx','com.mx','gob.mx','edu.mx','org.mx','net.mx']
    };

    for (const country of Object.keys(countryTlds)) {
        const opt = document.createElement('option');
        opt.value = country;
        opt.textContent = country;
        countrySelect.appendChild(opt);
    }

    countrySelect.addEventListener('change', () => {
        const domains = countryTlds[countrySelect.value] || [];
        domainsInput.value = domains.join(', ');
    });

    aboutBtn.addEventListener('click', () => {
        aboutText.classList.toggle('hidden');
    });

    function initMap() {
        map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);
    }
    initMap();

    function clearMap() {
        mapMarkers.forEach(m => map.removeLayer(m));
        mapMarkers = [];
        lastMapDomains = [];
        mapDiv.classList.add('hidden');
    }

    async function updateMap(domains) {
        lastMapDomains = Array.isArray(domains) ? [...domains] : [];
        if (!lastMapDomains.length) {
            clearMap();
            mapDiv.classList.add('hidden');
            return;
        }
        clearMap();
        mapDiv.classList.remove('hidden');
        map.invalidateSize();
        const generics = [];
        const coords = {};
        for (const d of lastMapDomains) {
            const tld = d.split('.').pop().toLowerCase();
            if (tld.length === 2) {
                if (!coords[tld]) {
                    try {
                        const info = await fetchWithTimeout(`https://restcountries.com/v3.1/alpha/${tld}`);
                        const c = info[0];
                        coords[tld] = { lat: c.latlng[0], lon: c.latlng[1], country: c.name.common, domains: [] };
                    } catch (e) { generics.push(d); continue; }
                }
                coords[tld].domains.push(d);
            } else generics.push(d);
        }
        Object.values(coords).forEach(c => {
            const marker = L.marker([c.lat, c.lon]).addTo(map).bindPopup(`${c.country}: ${c.domains.join(', ')}`);
            mapMarkers.push(marker);
        });
        if (generics.length) {
            const marker = L.marker([0, 0]).addTo(map).bindPopup(`${t('mapGenerics')}: ${generics.join(', ')}`);
            mapMarkers.push(marker);
        }
        map.setView([0, 0], 2);
    }

    const groupDefinitions = [
        {
            titleKey: 'groupNetwork',
            checks: [
                { key: 'ipinfo', label: 'More IP Info', default: true },
                { key: 'serverlocation', label: 'Server Location', default: true },
                { key: 'serverinfo', label: 'Server Info', default: true },
                { key: 'ipv4', label: 'IPv4', default: true },
                { key: 'ipv6', label: 'IPv6', default: false },
                { key: 'asn', label: 'ASN', default: true },
                { key: 'serverstatus', label: 'Server Status', default: true },
                { key: 'openports', label: 'Open Ports', default: false },
                { key: 'traceroute', label: 'Traceroute', default: false },
                { key: 'redirectchain', label: 'Redirect Chain', default: true },
                { key: 'block', label: 'Block Detection', default: false }
            ]
        },
        {
            titleKey: 'groupDns',
            checks: [
                { key: 'dnsrecords', label: 'DNS Records', default: true },
                { key: 'txtrecords', label: 'TXT Records', default: true },
                { key: 'dnsserver', label: 'DNS Server', default: true },
                { key: 'dnssecurity', label: 'DNS Security Extensions', default: true },
                { key: 'rpki', label: 'RPKI', default: false },
                { key: 'caa', label: 'CAA', default: false },
                { key: 'tlsa', label: 'TLSA', default: false }
            ]
        },
        {
            titleKey: 'groupMail',
            checks: [
                { key: 'emailconfig', label: 'Email Configuration', default: true },
                { key: 'mx', label: 'MX', default: false },
                { key: 'smtputf8', label: 'SMTPUTF8', default: false },
                { key: 'dmarc', label: 'DMARC', default: true },
                { key: 'spf', label: 'SPF', default: true },
                { key: 'dkim', label: 'DKIM', default: false }
            ]
        },
        {
            titleKey: 'groupIdentity',
            checks: [
                { key: 'whois', label: 'Whois Lookup', default: true },
                { key: 'domaininfo', label: 'Domain Info', default: true },
                { key: 'securitytxt', label: 'Security.txt', default: false }
            ]
        },
        {
            titleKey: 'groupExperience',
            checks: [
                { key: 'sitefeatures', label: 'Site Features', default: false },
                { key: 'cookies', label: 'Cookies', default: false },
                { key: 'crawlrules', label: 'Crawl Rules', default: false },
                { key: 'linkedpages', label: 'Linked Pages', default: false },
                { key: 'listedpages', label: 'Listed Pages', default: false },
                { key: 'socialtags', label: 'Social Tags', default: false },
                { key: 'quality', label: 'Quality Metrics', default: false },
                { key: 'archive', label: 'Archive History', default: false },
                { key: 'ranking', label: 'Global Ranking', default: false },
                { key: 'malware', label: 'Malware & Phishing Detection', default: false },
                { key: 'screenshot', label: 'Screenshot', default: false }
            ]
        },
        {
            titleKey: 'groupSecurity',
            checks: [
                { key: 'https', label: 'HTTPS', default: true },
                { key: 'redirect', label: 'HTTPS Redirect', default: true },
                { key: 'hsts', label: 'HTTP Strict Transport Security', default: true },
                { key: 'csp', label: 'Content Security Policy', default: false },
                { key: 'xfo', label: 'X-Frame-Options', default: false },
                { key: 'xcto', label: 'X-Content-Type-Options', default: false },
                { key: 'referrer', label: 'Referrer-Policy', default: false },
                { key: 'permissions', label: 'Permissions-Policy', default: false },
                { key: 'xxss', label: 'X-XSS-Protection', default: false },
                { key: 'headers', label: 'Headers', default: false },
                { key: 'server', label: 'Server Header', default: false },
                { key: 'compression', label: 'HTTP Compression', default: false },
                { key: 'ocsp', label: 'OCSP Stapling', default: false },
                { key: 'tls', label: 'TLS Version', default: true },
                { key: 'key', label: 'Key Exchange', default: false },
                { key: 'sslchain', label: 'SSL Chain Info', default: false },
                { key: 'tlsciphers', label: 'TLS Cipher Suites', default: false },
                { key: 'tlsconfig', label: 'TLS Security Config', default: false },
                { key: 'tlssimulation', label: 'TLS Handshake Simulation', default: false },
                { key: 'httpsecurity', label: 'HTTP Security Features', default: false },
                { key: 'firewall', label: 'Firewall Detection', default: false }
            ]
        }
    ];

    const checkConfig = {};
    groupDefinitions.forEach(group => {
        group.checks.forEach(check => {
            checkConfig[check.key] = { label: check.label };
        });
    });

    function renderCheckOptions() {
        const container = document.getElementById('checksContainer');
        container.innerHTML = '';
        groupDefinitions.forEach(group => {
            const details = document.createElement('details');
            details.className = 'border border-slate-200 rounded-xl bg-white shadow-sm';
            details.open = true;
            const summary = document.createElement('summary');
            summary.className = 'cursor-pointer select-none px-3 py-2 font-semibold text-slate-700 flex items-center justify-between';
            const titleSpan = document.createElement('span');
            titleSpan.dataset.groupTitle = group.titleKey;
            titleSpan.textContent = t(group.titleKey);
            const countSpan = document.createElement('span');
            countSpan.className = 'text-xs text-slate-500';
            countSpan.dataset.groupCount = group.checks.length;
            countSpan.textContent = `${group.checks.length} ${t('summaryChecksSuffix')}`;
            summary.appendChild(titleSpan);
            summary.appendChild(countSpan);
            details.appendChild(summary);
            const wrapper = document.createElement('div');
            wrapper.className = 'grid grid-cols-1 sm:grid-cols-2 gap-2 px-3 pb-3';
            group.checks.forEach(check => {
                const label = document.createElement('label');
                label.className = 'check-label flex items-center p-2 border border-slate-200 rounded-lg cursor-pointer bg-slate-50';
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.dataset.check = check.key;
                if (check.default) input.checked = true;
                input.className = 'h-4 w-4 rounded text-sky-600 focus:ring-sky-500';
                const span = document.createElement('span');
                span.className = 'ml-2 text-sm text-slate-700';
                span.textContent = check.label;
                label.appendChild(input);
                label.appendChild(span);
                wrapper.appendChild(label);
            });
            details.appendChild(wrapper);
            container.appendChild(details);
        });
        checkboxes = container.querySelectorAll('input[type="checkbox"][data-check]');
    }

    renderCheckOptions();

    function loadHistory() {
        const history = JSON.parse(localStorage.getItem('domainHistory') || '[]');
        if (!history.length) {
            historyDiv.innerHTML = `<div class="text-center text-slate-500">${escapeHtml(t('historyEmpty'))}</div>`;
            return;
        }
        let html = '';
        history.forEach(entry => {
            html += `<div class="mb-4"><h4 class="font-semibold mb-2">${entry.date}</h4>`;
            html += `<div class="overflow-auto"><table class="min-w-full text-sm border border-slate-200"><thead><tr><th class="border border-slate-200 px-2 py-1 bg-slate-50 text-left text-slate-700">${escapeHtml(t('historyDomain'))}</th>`;
            entry.checks.forEach(c => { html += `<th class="border border-slate-200 px-2 py-1 bg-slate-50 text-left text-slate-700">${checkConfig[c]?.label || c}</th>`; });
            html += '</tr></thead><tbody>';
            entry.domains.forEach(d => {
                html += `<tr><td class="border border-slate-200 px-2 py-1">${d.domain}</td>`;
                entry.checks.forEach(c => {
                    const val = d.results[c]?.status || '-';
                    html += `<td class="border border-slate-200 px-2 py-1 text-center">${val}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody></table></div></div>';
        });
        historyDiv.innerHTML = html;
    }

    function saveHistory(entry) {
        const history = JSON.parse(localStorage.getItem('domainHistory') || '[]');
        history.push(entry);
        localStorage.setItem('domainHistory', JSON.stringify(history));
    }

    function toASCII(domain) {
        try { return new URL('http://' + domain).hostname; }
        catch (e) { return domain; }
    }

    async function fetchWithTimeout(resource, options = {}, timeout = 20000) {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);
        try {
            const response = await fetch(resource, { ...options, signal: controller.signal });
            clearTimeout(id);
            if (!response.ok) throw new Error(t('serviceUnavailable'));
            return response.json();
        } catch (error) {
            clearTimeout(id);
            throw new Error(error.name === 'AbortError' ? t('requestTimeout') : t('serviceUnavailable'));
        }
    }

    async function getSecurityHeaders(domain) {
        const ascii = toASCII(domain);
        if (headerCache[ascii]) return headerCache[ascii];
        const data = await fetchWithTimeout(`${API_BASE}/headers/${ascii}`);
        headerCache[ascii] = data;
        return data;
    }

    async function getTlsInfo(domain) {
        const ascii = toASCII(domain);
        if (tlsCache[ascii]) return tlsCache[ascii];
        const data = await fetchWithTimeout(`${API_BASE}/tlsinfo/${ascii}`);
        tlsCache[ascii] = data;
        return data;
    }

    function escapeHtml(text) {
        return String(text)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    }

    function formatDetails(details) {
        if (details === undefined || details === null) return '';
        if (Array.isArray(details)) {
            return details
                .map(item => {
                    if (item && typeof item === 'object' && item.html) {
                        return `<div class="text-xs text-gray-700">${item.html}</div>`;
                    }
                    return `<div class="text-xs text-gray-700">${escapeHtml(item)}</div>`;
                })
                .join('');
        }
        if (details && typeof details === 'object') {
            if (details.html) return details.html;
            return `<pre class="text-xs text-gray-700 whitespace-pre-wrap">${escapeHtml(JSON.stringify(details, null, 2))}</pre>`;
        }
        return `<span class="text-sm">${escapeHtml(details)}</span>`;
    }

    function renderTooltipList(items, emptyText, isPositive = false) {
        if (!items.length) {
            return `<div class="text-xs text-slate-500">${escapeHtml(emptyText)}</div>`;
        }
        return `<ul class="space-y-1 text-xs text-slate-700">${items.map(item => {
            if (isPositive) {
                return `<li>${escapeHtml(item.domain)}</li>`;
            }
            const statusText = item.status === 'fail'
                ? t('statusFailed')
                : item.status === 'error'
                    ? t('statusError')
                    : item.status || '';
            const suffix = statusText ? ` (${escapeHtml(statusText)})` : '';
            return `<li>${escapeHtml(item.domain)}${suffix}</li>`;
        }).join('')}</ul>`;
    }

    function formatDate(dateString) {
        if (!dateString) return '';
        const date = new Date(dateString);
        if (Number.isNaN(date.getTime())) return dateString;
        const locale = localeMap[currentLang] || 'en-US';
        return date.toLocaleDateString(locale, { year: 'numeric', month: 'short', day: 'numeric' });
    }

    function initializeSummary(selectedChecks) {
        summaryData = {};
        summaryElements = {};
        summaryBody.innerHTML = '';
        if (!selectedChecks.length) {
            summarySection.classList.add('hidden');
            return;
        }
        summarySection.classList.remove('hidden');
        selectedChecks.forEach(checkKey => {
            const label = checkConfig[checkKey]?.label || checkKey;
            summaryData[checkKey] = { label, positive: 0, negative: 0, positives: [], negatives: [] };

            const row = document.createElement('tr');
            const labelCell = document.createElement('td');
            labelCell.className = 'px-4 py-3 font-medium text-slate-700';
            labelCell.textContent = label;
            row.appendChild(labelCell);

            const positiveCell = document.createElement('td');
            positiveCell.className = 'px-4 py-3 text-emerald-600';
            const positiveWrapper = document.createElement('div');
            positiveWrapper.className = 'relative group inline-block';
            const positiveCount = document.createElement('span');
            positiveCount.className = 'font-semibold cursor-help';
            positiveCount.textContent = '0';
            const positiveTooltip = document.createElement('div');
            positiveTooltip.className = 'summary-tooltip hidden group-hover:block absolute z-20 left-1/2 transform -translate-x-1/2 mt-2 w-56 max-h-48 overflow-y-auto bg-white border border-slate-200 rounded-lg shadow-lg p-3';
            positiveTooltip.innerHTML = renderTooltipList([], t('noPositiveResults'), true);
            positiveWrapper.appendChild(positiveCount);
            positiveWrapper.appendChild(positiveTooltip);
            positiveCell.appendChild(positiveWrapper);
            row.appendChild(positiveCell);

            const negativeCell = document.createElement('td');
            negativeCell.className = 'px-4 py-3 text-rose-600';
            const negativeWrapper = document.createElement('div');
            negativeWrapper.className = 'relative group inline-block';
            const negativeCount = document.createElement('span');
            negativeCount.className = 'font-semibold cursor-help';
            negativeCount.textContent = '0';
            const negativeTooltip = document.createElement('div');
            negativeTooltip.className = 'summary-tooltip hidden group-hover:block absolute z-20 left-1/2 transform -translate-x-1/2 mt-2 w-56 max-h-48 overflow-y-auto bg-white border border-slate-200 rounded-lg shadow-lg p-3';
            negativeTooltip.innerHTML = renderTooltipList([], t('noNegativeResults'));
            negativeWrapper.appendChild(negativeCount);
            negativeWrapper.appendChild(negativeTooltip);
            negativeCell.appendChild(negativeWrapper);
            row.appendChild(negativeCell);

            summaryBody.appendChild(row);
            summaryElements[checkKey] = { positiveCount, negativeCount, positiveTooltip, negativeTooltip };
        });
    }

    function updateSummary(checkKey, domain, status) {
        if (!summaryData[checkKey]) return;
        const entry = summaryData[checkKey];
        if (status === 'ok') {
            entry.positive += 1;
            entry.positives.push({ domain, status });
        } else {
            entry.negative += 1;
            entry.negatives.push({ domain, status });
        }
        const elements = summaryElements[checkKey];
        if (!elements) return;
        elements.positiveCount.textContent = entry.positive;
        elements.negativeCount.textContent = entry.negative;
        elements.positiveTooltip.innerHTML = renderTooltipList(entry.positives, t('noPositiveResults'), true);
        elements.negativeTooltip.innerHTML = renderTooltipList(entry.negatives, t('noNegativeResults'));
    }

    function getStatusHtml(status, details = '') {
        let icon, color;
        switch (status) {
            case 'ok':
                icon = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
                color = 'text-green-600';
                break;
            case 'fail':
                icon = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
                color = 'text-red-600';
                break;
            case 'error':
                icon = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
                color = 'text-gray-500';
                break;
            case 'info':
                icon = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
                color = 'text-blue-600';
                break;
            default:
                icon = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
                color = 'text-yellow-600';
                break;
        }
        return `<div class="flex items-start ${color}"><span class="mr-2 flex-shrink-0">${icon}</span><div class="space-y-1">${formatDetails(details)}</div></div>`;
    }

    function createResultCard(domain, selectedChecks) {
        const card = document.createElement('div');
        card.className = 'p-5 rounded-2xl bg-slate-50 border border-slate-200 shadow-sm';
        const title = document.createElement('h3');
        title.className = 'font-bold text-xl text-slate-900 mb-4 pb-2 border-b border-slate-200';
        title.textContent = domain;
        card.appendChild(title);

        const placeholders = {};

        for (const group of groupDefinitions) {
            const groupKeys = group.checks.map(c => c.key);
            const filtered = selectedChecks.filter(c => groupKeys.includes(c));
            if (!filtered.length) continue;
            const h4 = document.createElement('h4');
            h4.className = 'text-md font-semibold text-slate-800 mt-4 mb-2';
            h4.dataset.groupTitle = group.titleKey;
            h4.textContent = t(group.titleKey);
            card.appendChild(h4);
            filtered.forEach(c => {
                const row = document.createElement('div');
                row.className = 'result-item flex justify-between items-center py-2 border-b border-slate-200 last:border-b-0';
                const label = document.createElement('span');
                label.className = 'label text-sm font-medium text-slate-700';
                label.textContent = checkConfig[c].label;
                const placeholder = document.createElement('span');
                placeholder.className = 'text-slate-500 flex items-center';
                placeholder.innerHTML = `<div class="loader mr-2"></div><span>${escapeHtml(t('loadingIndicator'))}</span>`;
                row.appendChild(label);
                row.appendChild(placeholder);
                card.appendChild(row);
                placeholders[c] = placeholder;
            });
        }

        resultsContainer.appendChild(card);
        return placeholders;
    }

    async function getCheckResult(checkType, domain) {
        const { label } = checkConfig[checkType];
        const ascii = toASCII(domain);
        try {
            switch (checkType) {
                case 'ipinfo': {
                    const data = await fetchWithTimeout(`${API_BASE}/ipinfo/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const lines = [];
                    if (data.ipv4?.length) lines.push(`IPv4: ${data.ipv4.join(', ')}`);
                    if (data.ipv6?.length) lines.push(`IPv6: ${data.ipv6.join(', ')}`);
                    if (data.geo?.length) {
                        data.geo.forEach(g => {
                            lines.push(`${g.ip}: ${[g.city, g.region, g.country].filter(Boolean).join(', ')}${g.asn ? ' (AS' + g.asn + ')' : ''}`);
                        });
                    }
                    return { label, status: lines.length ? 'ok' : 'fail', details: lines.length ? lines : 'No data' };
                }
                case 'serverlocation': {
                    const data = await fetchWithTimeout(`${API_BASE}/serverlocation/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const parts = [data.city, data.region, data.country].filter(Boolean).join(', ');
                    const details = [];
                    if (parts || data.ip) details.push(parts ? `${parts} (${data.ip})` : data.ip);
                    if (data.timezone) details.push(`Time zone: ${data.timezone}`);
                    if (data.latitude != null && data.longitude != null) {
                        details.push(`Coordinates: ${data.latitude}, ${data.longitude}`);
                    }
                    return {
                        label,
                        status: data.ip ? 'ok' : 'fail',
                        details: details.length ? details : 'No data'
                    };
                }
                case 'serverinfo': {
                    const data = await fetchWithTimeout(`${API_BASE}/serverinfo/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const lines = [];
                    if (data.ip) lines.push(`Analyzed IP: ${data.ip}`);
                    if (data.asn) lines.push(`ASN: AS${data.asn}`);
                    if (data.org) lines.push(`Organization: ${data.org}`);
                    if (data.network) lines.push(`Prefix: ${data.network}`);
                    if (data.isp) lines.push(`ISP: ${data.isp}`);
                    if (data.city || data.country) lines.push(`Location: ${[data.city, data.country].filter(Boolean).join(', ')}`);
                    return { label, status: lines.length ? 'ok' : 'fail', details: lines.length ? lines : 'No data' };
                }
                case 'serverstatus': {
                    const data = await fetchWithTimeout(`${API_BASE}/serverstatus/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const code = data.statusCode;
                    if (!code) return { label, status: 'error', details: 'No response' };
                    if (code >= 500) return { label, status: 'fail', details: `HTTP ${code}` };
                    if (code >= 400) return { label, status: 'fail', details: `HTTP ${code}` };
                    if (code >= 300) {
                        const target = data.location ? ` â†’ ${data.location}` : '';
                        return { label, status: 'info', details: `HTTP ${code} (redirect)${target}` };
                    }
                    return { label, status: 'ok', details: `HTTP ${code}` };
                }
                case 'openports': {
                    const data = await fetchWithTimeout(`${API_BASE}/openports/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const open = data.ports?.filter(p => p.open).map(p => p.port) || [];
                    const expected = new Set([53, 80, 443, 25, 110, 143, 465, 587, 993, 995]);
                    const unusual = open.filter(port => !expected.has(port));
                    if (!open.length) {
                        return { label, status: 'ok', details: 'No common ports open' };
                    }
                    if (unusual.length) {
                        const details = [`Non-standard ports: ${unusual.join(', ')}`];
                        if (open.length > unusual.length) {
                            const standard = open.filter(port => expected.has(port));
                            details.push(`Expected ports: ${standard.join(', ')}`);
                        }
                        return { label, status: 'fail', details };
                    }
                    return { label, status: 'ok', details: `Standard ports: ${open.join(', ')}` };
                }
                case 'traceroute': {
                    const data = await fetchWithTimeout(`${API_BASE}/traceroute/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const hops = data.hops?.slice(0, 10) || [];
                    return { label, status: hops.length ? 'ok' : 'info', details: hops.length ? hops : 'No data' };
                }
                case 'redirectchain': {
                    const data = await fetchWithTimeout(`${API_BASE}/redirectchain/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const chain = (data.chain || []).filter(Boolean);
                    if (!chain.length) {
                        return { label, status: 'info', details: 'No redirects' };
                    }
                    const deduped = [];
                    const seen = new Set();
                    chain.forEach(step => {
                        const key = `${step.statusCode}-${step.url}-${step.location || ''}`;
                        if (!seen.has(key)) {
                            seen.add(key);
                            deduped.push(step);
                        }
                    });
                    const finalStep = deduped[deduped.length - 1];
                    const lines = deduped.map((step, index) => {
                        const code = step.statusCode ? `HTTP ${step.statusCode}` : 'No status code';
                        const destination = step.location || step.url;
                        const note = index === deduped.length - 1 ? 'final destination' : 'redirect';
                        return `${index + 1}. ${code} â†’ ${destination} (${note})`;
                    });
                    const summary = `Chain of ${deduped.length} steps. Last destination: ${finalStep.location || finalStep.url}`;
                    let status = 'info';
                    if (finalStep.statusCode >= 400) status = 'fail';
                    else if (deduped.length === 1 && finalStep.statusCode < 300) status = 'ok';
                    return { label, status, details: [summary, ...lines] };
                }
                case 'block': {
                    const data = await fetchWithTimeout(`${API_BASE}/block/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const lines = data.results?.map(r => `${r.resolver}: ${r.blocked ? 'blocked' : 'allowed'}`) || [];
                    const blocked = data.results?.some(r => r.blocked);
                    return { label, status: blocked ? 'fail' : 'ok', details: lines.length ? lines : 'No data' };
                }
                case 'dnsrecords': {
                    const data = await fetchWithTimeout(`${API_BASE}/dnsrecords/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const records = [];
                    Object.entries(data.records || {}).forEach(([type, values]) => {
                        if (Array.isArray(values) && values.length) {
                            const formatted = values
                                .map(v => (typeof v === 'string' ? v : JSON.stringify(v)))
                                .join(', ');
                            records.push(`${type}: ${formatted}`);
                        }
                    });
                    return { label, status: records.length ? 'ok' : 'fail', details: records.length ? records : 'No records found' };
                }
                case 'txtrecords': {
                    const data = await fetchWithTimeout(`${API_BASE}/txtrecords/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const records = data.records?.map(r => r.join('')) || [];
                    return { label, status: records.length ? 'ok' : 'fail', details: records.length ? records : 'No TXT records' };
                }
                case 'dnsserver': {
                    const data = await fetchWithTimeout(`${API_BASE}/dnsserver/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.servers?.length ? 'ok' : 'fail', details: data.servers?.length ? data.servers : 'No name servers found' };
                }
                case 'dnssecurity': {
                    const data = await fetchWithTimeout(`${API_BASE}/dnssecurity/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const lines = [];
                    if (data.algorithms?.length) lines.push(`Algorithms: ${data.algorithms.join(', ')}`);
                    if (data.doh) lines.push('DoH enabled');
                    lines.push(data.valid ? 'DNSSEC validated' : 'DNSSEC not present');
                    return { label, status: data.valid ? 'ok' : 'fail', details: lines };
                }
                case 'emailconfig': {
                    const data = await fetchWithTimeout(`${API_BASE}/emailconfig/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const lines = [
                        `SPF: ${data.spf ? 'yes' : 'no'}`,
                        `DMARC: ${data.dmarc ? 'yes' : 'no'}`,
                        `DKIM: ${data.dkim ? 'yes' : 'no'}`
                    ];
                    if (data.mx?.length) lines.push(`MX: ${data.mx.map(m => `${m.exchange} (p${m.priority})`).join(', ')}`);
                    return { label, status: data.spf || data.dmarc || data.dkim ? 'ok' : 'fail', details: lines };
                }
                case 'sitefeatures': {
                    const data = await fetchWithTimeout(`${API_BASE}/sitefeatures/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const features = data.features || {};
                    const lines = Object.entries(features).map(([k, v]) => {
                        const clean = k.replace(/^has/, '').replace(/([A-Z])/g, ' $1').trim();
                        const formatted = clean.charAt(0).toUpperCase() + clean.slice(1);
                        return `${formatted}: ${v ? 'yes' : 'no'}`;
                    });
                    return { label, status: lines.some(l => /yes$/.test(l)) ? 'ok' : 'info', details: lines };
                }
                case 'cookies': {
                    const data = await fetchWithTimeout(`${API_BASE}/cookies/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const cookies = data.cookies || [];
                    return { label, status: cookies.length ? 'info' : 'ok', details: cookies.length ? cookies : 'No cookies detected' };
                }
                case 'crawlrules': {
                    const data = await fetchWithTimeout(`${API_BASE}/crawlrules/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    if (!data.found) return { label, status: 'fail', details: 'Not found' };
                    const snippet = escapeHtml((data.content || '').slice(0, 500));
                    const html = `<pre class="whitespace-pre-wrap text-xs text-slate-700">${snippet}${data.content && data.content.length > 500 ? 'â€¦' : ''}</pre>`;
                    return { label, status: 'ok', details: { html } };
                }
                case 'linkedpages': {
                    const data = await fetchWithTimeout(`${API_BASE}/linkedpages/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const lines = data.links?.slice(0, 20).map(l => `${l.internal ? 'Internal' : 'External'}: ${l.href}`) || [];
                    return { label, status: lines.length ? 'ok' : 'info', details: lines.length ? lines : 'No links detected' };
                }
                case 'listedpages': {
                    const data = await fetchWithTimeout(`${API_BASE}/listedpages/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const pages = data.pages?.slice(0, 20) || [];
                    return { label, status: pages.length ? 'ok' : 'info', details: pages.length ? pages : 'No sitemap' };
                }
                case 'socialtags': {
                    const data = await fetchWithTimeout(`${API_BASE}/socialtags/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const tags = Object.entries(data.tags || {}).map(([k, v]) => `${k}: ${v}`);
                    return { label, status: tags.length ? 'ok' : 'info', details: tags.length ? tags : 'No social tags' };
                }
                case 'quality': {
                    const data = await fetchWithTimeout(`${API_BASE}/quality/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const lines = [];
                    if (typeof data.performance === 'number') lines.push(`Performance: ${(data.performance * 100).toFixed(0)}`);
                    if (typeof data.accessibility === 'number') lines.push(`Accessibility: ${(data.accessibility * 100).toFixed(0)}`);
                    if (typeof data.bestPractices === 'number') lines.push(`Best practices: ${(data.bestPractices * 100).toFixed(0)}`);
                    if (typeof data.seo === 'number') lines.push(`SEO: ${(data.seo * 100).toFixed(0)}`);
                    return { label, status: lines.length ? 'ok' : 'info', details: lines.length ? lines : 'No Lighthouse data' };
                }
                case 'archive': {
                    const data = await fetchWithTimeout(`${API_BASE}/archive/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const entries = data.entries?.map(e => `${e.timestamp}: ${e.original} (${e.status})`) || [];
                    return { label, status: entries.length ? 'ok' : 'info', details: entries.length ? entries : 'No historical data' };
                }
                case 'ranking': {
                    const data = await fetchWithTimeout(`${API_BASE}/ranking/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return {
                        label,
                        status: data.rank ? 'ok' : 'info',
                        details: data.rank ? `Global ranking ${data.rank}${data.date ? ` (${data.date})` : ''}` : 'No ranking data'
                    };
                }
                case 'malware': {
                    const data = await fetchWithTimeout(`${API_BASE}/malware/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const entries = data.entries?.map(e => `${e.url || e.id} (${e.status || 'listado'})`) || [];
                    const threat = data.threat && data.threat !== 'ok';
                    return { label, status: threat ? 'fail' : 'ok', details: entries.length ? entries : 'No reports' };
                }
                case 'screenshot': {
                    const data = await fetchWithTimeout(`${API_BASE}/screenshot/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const link = `<a class="text-blue-600 underline" href="${escapeHtml(data.imageUrl)}" target="_blank" rel="noopener">View capture</a>`;
                    return { label, status: 'info', details: { html: link } };
                }
                case 'headers': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const entries = Object.entries(data.headers || {}).map(([k, v]) => `${k}: ${Array.isArray(v) ? v.join(', ') : v}`);
                    return { label, status: entries.length ? 'ok' : 'info', details: entries.length ? entries : 'No headers' };
                }
                case 'sslchain': {
                    const data = await fetchWithTimeout(`${API_BASE}/sslchain/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const chain = data.chain?.map(c => `${c.subject?.CN || 'Certificate'} â†’ ${c.issuer?.CN || 'Issuer'} (${c.valid_from} - ${c.valid_to})`) || [];
                    return { label, status: chain.length ? 'ok' : 'fail', details: chain.length ? chain : 'No SSL chain' };
                }
                case 'tlsciphers': {
                    const data = await fetchWithTimeout(`${API_BASE}/tlsciphers/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const suites = data.suites?.map(s => `${s.protocol}: ${s.cipher}`) || [];
                    return { label, status: suites.length ? 'ok' : 'info', details: suites.length ? suites : 'No information' };
                }
                case 'tlsconfig': {
                    const data = await fetchWithTimeout(`${API_BASE}/tlsconfig/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    if (data.data?.error) return { label, status: 'error', details: data.data.error };
                    const score = data.data?.score;
                    const details = [];
                    if (score !== undefined) details.push(`Score: ${score}`);
                    if (data.data?.tests) {
                        Object.entries(data.data.tests).slice(0, 10).forEach(([name, result]) => {
                            if (result && typeof result === 'object' && result.output) {
                                details.push(`${name}: ${result.output}`);
                            }
                        });
                    }
                    return { label, status: score !== undefined ? 'ok' : 'info', details: details.length ? details : 'No data' };
                }
                case 'tlssimulation': {
                    const data = await fetchWithTimeout(`${API_BASE}/tlssimulation/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const scenarios = data.scenarios?.map(s => `${s.client}: ${s.success ? `${s.protocol || 'TLS'} (${s.cipher || 'unknown cipher'})` : 'failed'}`) || [];
                    const success = data.scenarios?.every(s => s.success);
                    return { label, status: success ? 'ok' : 'fail', details: scenarios.length ? scenarios : 'No data' };
                }
                case 'httpsecurity': {
                    const data = await fetchWithTimeout(`${API_BASE}/httpsecurity/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const security = data.security || {};
                    const lines = Object.entries(security).map(([k, v]) => `${k.toUpperCase()}: ${v ? 'yes' : 'no'}`);
                    const ok = Object.values(security).some(Boolean);
                    return { label, status: ok ? 'ok' : 'fail', details: lines.length ? lines : 'No security headers' };
                }
                case 'firewall': {
                    const data = await fetchWithTimeout(`${API_BASE}/firewall/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return {
                        label,
                        status: data.detected ? 'ok' : 'info',
                        details: data.detected ? `Detected: ${data.waf.join(', ')}` : 'No WAF detected'
                    };
                }
                case 'dnssec': {
                    const data = await fetchWithTimeout(`${API_BASE}/dnssec/${ascii}`);
                    const ok = data.valid;
                    const details = ok
                        ? (data.algorithms?.length ? `Algorithms: ${data.algorithms.join(', ')}` : 'DNSSEC configured')
                        : 'DNSSEC missing';
                    return { label, status: ok ? 'ok' : 'fail', details };
                }
                case 'ipv4': {
                    const data = await fetchWithTimeout(`https://dns.google/resolve?name=${ascii}&type=A`);
                    const ips = data.Answer?.filter(r => r.type === 1).map(r => r.data) || [];
                    const geos = [];
                    for (const ip of ips) {
                        try {
                            const info = await fetchWithTimeout(`https://ipapi.co/${ip}/json/`);
                            geos.push({ ip, country: info.country_name, lat: info.latitude, lon: info.longitude, asn: info.asn });
                        } catch (e) {}
                    }
                    const details = ips.length ? ips.join(', ') : 'IPv4 not available';
                    return { label, status: ips.length ? 'ok' : 'fail', details, geos };
                }
                case 'ipv6': {
                    const data = await fetchWithTimeout(`https://dns.google/resolve?name=${ascii}&type=AAAA`);
                    const ips = data.Answer?.filter(r => r.type === 28).map(r => r.data) || [];
                    return { label, status: ips.length ? 'ok' : 'fail', details: ips.length ? ips.join(', ') : 'IPv6 not available' };
                }
                case 'asn': {
                    const data = await fetchWithTimeout(`${API_BASE}/serverinfo/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return {
                        label,
                        status: data.asn ? 'ok' : 'fail',
                        details: data.asn ? `AS${data.asn}${data.org ? ` (${data.org})` : ''}` : 'No data'
                    };
                }
                case 'dmarc': {
                    const data = await fetchWithTimeout(`https://dns.google/resolve?name=_dmarc.${ascii}&type=TXT`);
                    const found = data.Answer?.some(r => r.data.includes("v=DMARC1"));
                    return { label, status: found ? 'ok' : 'fail', details: found ? 'Policy found' : 'DMARC not supported' };
                }
                case 'spf': {
                    const data = await fetchWithTimeout(`https://dns.google/resolve?name=${ascii}&type=TXT`);
                    const found = data.Answer?.some(r => r.data.includes("v=spf1"));
                    return { label, status: found ? 'ok' : 'fail', details: found ? 'Policy found' : 'SPF not supported' };
                }
                case 'dkim': {
                    const data = await fetchWithTimeout(`${API_BASE}/dkim/${ascii}?selector=default`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.found ? 'ok' : 'fail', details: data.found ? 'Record found' : 'DKIM not supported' };
                }
                case 'mx': {
                    const data = await fetchWithTimeout(`${API_BASE}/mx/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const details = data.records?.map(r => `${r.exchange} (p${r.priority})`).join(', ') || 'MX not supported';
                    return { label, status: data.records?.length ? 'ok' : 'fail', details };
                }
                case 'smtputf8': {
                    const data = await fetchWithTimeout(`${API_BASE}/smtputf8/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const details = data.results?.map(r => {
                        switch (r.status) {
                            case 'supports': return `${r.server}: yes`;
                            case 'no': return `${r.server}: no`;
                            case 'timeout': return `${r.server}: timeout`;
                            case 'connection-error': return `${r.server}: no connection`;
                            default: return `${r.server}: no data`;
                        }
                    }).join('; ') || 'SMTPUTF8 not supported';
                    const ok = data.results?.length && data.results.every(r => r.status === 'supports');
                    return { label, status: ok ? 'ok' : 'fail', details };
                }
                case 'rpki': {
                    const data = await fetchWithTimeout(`${API_BASE}/rpki/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    if (!data.results?.length) return { label, status: 'error', details: 'No data' };
                    const details = data.results.map(r => {
                        const state = r.state === 'valid' ? 'valid' : r.state === 'invalid' ? 'invalid' : 'unknown';
                        const asn = r.asn ? ` AS${r.asn}` : '';
                        const prefix = r.prefix ? ` (${r.prefix})` : '';
                        return `${r.ip}: ${state}${asn}${prefix}`;
                    });
                    let status = 'info';
                    if (data.results.some(r => r.state === 'invalid')) status = 'fail';
                    else if (data.results.some(r => r.state === 'valid')) status = data.valid ? 'ok' : 'info';
                    return { label, status, details };
                }
                case 'domaininfo': {
                    const data = await fetchWithTimeout(`${API_BASE}/domaininfo/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const lines = [];
                    if (data.registry) lines.push(`Registry: ${data.registry}`);
                    if (Array.isArray(data.status) && data.status.length) {
                        lines.push(`Statuses: ${data.status.join(', ')}`);
                    }
                    if (data.creation) lines.push(`Created: ${formatDate(data.creation)}`);
                    if (data.expiration) lines.push(`Expires: ${formatDate(data.expiration)}`);
                    return { label, status: lines.length ? 'ok' : 'info', details: lines.length ? lines : 'No data' };
                }
                case 'whois': {
                    const data = await fetchWithTimeout(`${API_BASE}/whois/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const details = data.country ? `${data.name || 'Unknown'} (${data.country})` : (data.name || 'Unknown');
                    return { label, status: data.name ? 'ok' : 'fail', details };
                }
                case 'https': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.https ? 'ok' : 'fail', details: data.https ? 'Accesible' : 'No responde HTTPS' };
                }
                case 'redirect': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.redirect ? 'ok' : 'fail', details: data.redirect ? 'Redirige a HTTPS' : 'No redirige' };
                }
                case 'hsts': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.hsts ? 'ok' : 'fail', details: data.hsts ? 'Header present' : 'Missing HSTS' };
                }
                case 'csp': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.csp ? 'ok' : 'fail', details: data.csp ? 'Header present' : 'Missing CSP' };
                }
                case 'xfo': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.xfo ? 'ok' : 'fail', details: data.xfo ? 'Header present' : 'Missing X-Frame-Options' };
                }
                case 'xcto': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.xcto ? 'ok' : 'fail', details: data.xcto ? 'Header present' : 'Missing X-Content-Type-Options' };
                }
                case 'referrer': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.referrer ? 'ok' : 'fail', details: data.referrer ? 'Header present' : 'Missing Referrer-Policy' };
                }
                case 'permissions': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.permissions ? 'ok' : 'fail', details: data.permissions ? 'Header present' : 'Missing Permissions-Policy' };
                }
                case 'xxss': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.xxss ? 'ok' : 'fail', details: data.xxss ? 'Header present' : 'Missing X-XSS-Protection' };
                }
                case 'server': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.server ? 'fail' : 'ok', details: data.server || 'Not exposed' };
                }
                case 'compression': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.compression ? 'ok' : 'fail', details: data.compression ? 'Compression enabled' : 'No compression' };
                }
                case 'ocsp': {
                    const data = await getTlsInfo(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.ocsp ? 'ok' : 'fail', details: data.ocsp ? 'OCSP stapling enabled' : 'No OCSP stapling' };
                }
                case 'tls': {
                    const data = await getTlsInfo(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const ok = data.protocol === 'TLSv1.3' || data.protocol === 'TLSv1.2';
                    return { label, status: ok ? 'ok' : 'fail', details: data.protocol || 'Unknown' };
                }
                case 'key': {
                    const data = await getTlsInfo(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const info = data.key || {};
                    let ok = false;
                    if (info.type === 'ECDH') ok = info.size >= 224;
                    else if (info.type === 'DH') ok = info.size >= 2048;
                    else ok = true;
                    const details = info.type ? `${info.type}${info.size ? ' ' + info.size : ''}` : 'No data';
                    return { label, status: ok ? 'ok' : 'fail', details };
                }
                case 'caa': {
                    const data = await fetchWithTimeout(`${API_BASE}/caa/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.records?.length ? 'ok' : 'fail', details: data.records?.length ? data.records.join(', ') : 'No CAA records' };
                }
                case 'tlsa': {
                    const data = await fetchWithTimeout(`${API_BASE}/tlsa/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.records?.length ? 'ok' : 'fail', details: data.records?.length ? data.records.join(', ') : 'No TLSA records' };
                }
                case 'securitytxt': {
                    const data = await fetchWithTimeout(`${API_BASE}/securitytxt/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.found ? 'ok' : 'fail', details: data.found ? 'Found' : 'Not available' };
                }
            }
        } catch (error) {
            return { label, status: 'error', details: error.message };
        }
    }

    async function analyzeDomain(domain, selectedChecks) {
        const placeholders = createResultCard(domain, selectedChecks);
        const finalResults = {};
        const promises = selectedChecks.map(async checkType => {
            try {
                const res = await getCheckResult(checkType, domain);
                finalResults[checkType] = res;
                placeholders[checkType].innerHTML = getStatusHtml(res.status, res.details);
                updateSummary(checkType, domain, res.status);
            } catch (err) {
                finalResults[checkType] = { label: checkConfig[checkType].label, status: 'error', details: err.message };
                placeholders[checkType].innerHTML = getStatusHtml('error', err.message);
                updateSummary(checkType, domain, 'error');
            }
        });
        await Promise.allSettled(promises);
        return { domain, results: finalResults };
    }

    async function handleAnalysis() {
        resultsContainer.innerHTML = '';
        loader.style.display = 'flex';
        checkButton.disabled = true;
        clearMap();

        const domains = domainsInput.value.trim().split(',').map(d => d.trim()).filter(Boolean);
        const selectedChecks = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.dataset.check);
        initializeSummary(selectedChecks);

        if (!domains.length || !selectedChecks.length) {
            loader.style.display = 'none';
            checkButton.disabled = false;
            resultsContainer.innerHTML = `<div class="text-center text-slate-500 p-4">${!domains.length ? 'Please enter at least one domain.' : 'Select at least one verification.'}</div>`;
            initializeSummary([]);
            return;
        }

        const historyEntry = { date: new Date().toLocaleString(localeMap[currentLang] || 'en-US'), checks: selectedChecks, domains: [] };
        const promises = domains.map(d => analyzeDomain(d, selectedChecks));
        const results = await Promise.all(promises);
        historyEntry.domains = results;
        await updateMap(domains);
        saveHistory(historyEntry);

        loader.style.display = 'none';
        checkButton.disabled = false;
    }

    historyButton.addEventListener('click', () => {
        const hidden = historyDiv.classList.toggle('hidden');
        if (!hidden) loadHistory();
    });

    clearHistoryButton.addEventListener('click', () => {
        localStorage.removeItem('domainHistory');
        loadHistory();
    });

    selectAllBtn.addEventListener('click', () => {
        checkboxes.forEach(cb => cb.checked = true);
    });

    checkButton.addEventListener('click', handleAnalysis);
</script>
</body>
</html>
